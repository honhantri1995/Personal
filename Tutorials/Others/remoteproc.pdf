%PDF-1.4
%“Œ‹ž ReportLab Generated PDF document http://www.reportlab.com
1 0 obj
<<
/F1 2 0 R /F2 3 0 R /F3 4 0 R /F4 5 0 R
>>
endobj
2 0 obj
<<
/BaseFont /Helvetica /Encoding /WinAnsiEncoding /Name /F1 /Subtype /Type1 /Type /Font
>>
endobj
3 0 obj
<<
/BaseFont /Helvetica-Bold /Encoding /WinAnsiEncoding /Name /F2 /Subtype /Type1 /Type /Font
>>
endobj
4 0 obj
<<
/BaseFont /Courier /Encoding /WinAnsiEncoding /Name /F3 /Subtype /Type1 /Type /Font
>>
endobj
5 0 obj
<<
/BaseFont /Helvetica-BoldOblique /Encoding /WinAnsiEncoding /Name /F4 /Subtype /Type1 /Type /Font
>>
endobj
6 0 obj
<<
/Contents 23 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 22 0 R /Resources <<
/Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]
>> /Rotate 0 /Trans <<

>> 
  /Type /Page
>>
endobj
7 0 obj
<<
/Contents 24 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 22 0 R /Resources <<
/Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]
>> /Rotate 0 /Trans <<

>> 
  /Type /Page
>>
endobj
8 0 obj
<<
/Contents 25 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 22 0 R /Resources <<
/Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]
>> /Rotate 0 /Trans <<

>> 
  /Type /Page
>>
endobj
9 0 obj
<<
/Contents 26 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 22 0 R /Resources <<
/Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]
>> /Rotate 0 /Trans <<

>> 
  /Type /Page
>>
endobj
10 0 obj
<<
/Contents 27 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 22 0 R /Resources <<
/Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]
>> /Rotate 0 /Trans <<

>> 
  /Type /Page
>>
endobj
11 0 obj
<<
/Contents 28 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 22 0 R /Resources <<
/Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]
>> /Rotate 0 /Trans <<

>> 
  /Type /Page
>>
endobj
12 0 obj
<<
/Outlines 14 0 R /PageLabels 29 0 R /PageMode /UseNone /Pages 22 0 R /Type /Catalog
>>
endobj
13 0 obj
<<
/Author () /CreationDate (D:20200228171721+00'00') /Creator (\(unspecified\)) /Keywords () /ModDate (D:20200228171721+00'00') /Producer (ReportLab PDF Library - www.reportlab.com) 
  /Subject (\(unspecified\)) /Title (Remote Processor Framework) /Trapped /False
>>
endobj
14 0 obj
<<
/Count 7 /First 15 0 R /Last 21 0 R /Type /Outlines
>>
endobj
15 0 obj
<<
/Dest [ 6 0 R /XYZ 62.69291 729.0236 0 ] /Next 16 0 R /Parent 14 0 R /Title (Introduction)
>>
endobj
16 0 obj
<<
/Dest [ 6 0 R /XYZ 62.69291 498.0236 0 ] /Next 17 0 R /Parent 14 0 R /Prev 15 0 R /Title (User API)
>>
endobj
17 0 obj
<<
/Dest [ 7 0 R /XYZ 62.69291 717.0236 0 ] /Next 18 0 R /Parent 14 0 R /Prev 16 0 R /Title (Typical usage)
>>
endobj
18 0 obj
<<
/Dest [ 7 0 R /XYZ 62.69291 398.8236 0 ] /Next 19 0 R /Parent 14 0 R /Prev 17 0 R /Title (API for implementors)
>>
endobj
19 0 obj
<<
/Dest [ 8 0 R /XYZ 62.69291 284.2236 0 ] /Next 20 0 R /Parent 14 0 R /Prev 18 0 R /Title (Implementation callbacks)
>>
endobj
20 0 obj
<<
/Dest [ 9 0 R /XYZ 62.69291 591.0236 0 ] /Next 21 0 R /Parent 14 0 R /Prev 19 0 R /Title (Binary Firmware Structure)
>>
endobj
21 0 obj
<<
/Dest [ 11 0 R /XYZ 62.69291 765.0236 0 ] /Parent 14 0 R /Prev 20 0 R /Title (Virtio and remoteproc)
>>
endobj
22 0 obj
<<
/Count 6 /Kids [ 6 0 R 7 0 R 8 0 R 9 0 R 10 0 R 11 0 R ] /Type /Pages
>>
endobj
23 0 obj
<<
/Length 5503
>>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 4 Tm /F2 20 Tf 24 TL 90.45488 0 Td (Remote Processor Framework) Tj T* -90.45488 0 Td ET
Q
Q
q
1 0 0 1 62.69291 708.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Introduction) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 666.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 2.251976 Tw (Modern SoCs typically have heterogeneous remote processor devices in asymmetric multiprocessing) Tj T* 0 Tw .39784 Tw (\(AMP\) configurations, which may be running different instances of operating system, whether it's Linux or) Tj T* 0 Tw (any other flavor of real-time OS.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 624.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .849984 Tw (OMAP4, for example, has dual Cortex-A9, dual Cortex-M3 and a C64x+ DSP. In a typical configuration,) Tj T* 0 Tw 1.185542 Tw (the dual cortex-A9 is running Linux in a SMP configuration, and each of the other three cores \(two M3) Tj T* 0 Tw (cores and a DSP\) is running its own instance of RTOS in an AMP configuration.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 510.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 98 Tm /F1 10 Tf 12 TL 1.542706 Tw (The remoteproc framework allows different platforms/architectures to control \(power on, load firmware,) Tj T* 0 Tw 2.627674 Tw (power off\) those remote processors while abstracting the hardware differences, so the entire driver) Tj T* 0 Tw 2.148651 Tw (doesn't need to be duplicated. In addition, this framework also adds rpmsg virtio devices for remote) Tj T* 0 Tw .765814 Tw (processors that supports this kind of communication. This way, platform-specific remoteproc drivers only) Tj T* 0 Tw 2.729986 Tw (need to provide a few low-level handlers, and then all rpmsg drivers will then just work \(for more) Tj T* 0 Tw 2.650888 Tw (information about the virtio-based rpmsg bus and its drivers, please read Documentation/rpmsg.txt\).) Tj T* 0 Tw .211751 Tw (Registration of other types of virtio devices is now also possible. Firmwares just need to publish what kind) Tj T* 0 Tw .962339 Tw (of virtio devices do they support, and then remoteproc will add those devices. This makes it possible to) Tj T* 0 Tw (reuse the existing virtio drivers with remote processor backends at a minimal development cost.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 477.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (User API) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 443.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (int rproc_boot\(struct rproc *rproc\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 423.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Boot a remote processor \(i.e. load its firmware, power it on, ...\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 405.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (If the remote processor is already powered on, this function immediately returns \(successfully\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 351.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL 1.333735 Tw (Returns 0 on success, and an appropriate error value otherwise. Note: to use this function you should) Tj T* 0 Tw .27528 Tw (already have a valid rproc handle. There are several ways to achieve that cleanly \(devres, pdata, the way) Tj T* 0 Tw .575366 Tw (remoteproc_rpmsg.c does this, or, if this becomes prevalent, we might also consider using dev_archdata) Tj T* 0 Tw (for this\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 318.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (void rproc_shutdown\(struct rproc *rproc\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 274.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .45936 Tw (Power off a remote processor \(previously booted with rproc_boot\(\)\). In case @rproc is still being used by) Tj T* 0 Tw 1.720651 Tw (an additional user\(s\), then this function will just decrement the power refcount and exit, without really) Tj T* 0 Tw (powering off the device.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 244.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 2.757674 Tw (Every call to rproc_boot\(\) must \(eventually\) be accompanied by a call to rproc_shutdown\(\). Calling) Tj T* 0 Tw (rproc_shutdown\(\) redundantly is a bug.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 232.6236 cm
Q
q
1 0 0 1 62.69291 137.6236 cm
.960784 .960784 .862745 rg
n 0 95 469.8898 -95 re f*
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 6 69 Tm  T* ET
q
1 0 0 1 16 64 cm
q
0 0 0 rg
BT 1 0 0 1 0 2.5 Tm /F4 12.5 Tf 15 TL (Note) Tj T* ET
Q
Q
q
1 0 0 1 16 16 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .06784 Tw (we're not decrementing the rproc's refcount, only the power refcount. which means that the @rproc) Tj T* 0 Tw .068651 Tw (handle stays valid even after rproc_shutdown\(\) returns, and users can still use it with a subsequent) Tj T* 0 Tw (rproc_boot\(\), if needed.) Tj T* ET
Q
Q
q
1 J
1 j
.662745 .662745 .662745 RG
.5 w
n 0 95 m 469.8898 95 l S
n 0 0 m 469.8898 0 l S
n 0 0 m 0 95 l S
n 469.8898 0 m 469.8898 95 l S
Q
Q
q
1 0 0 1 62.69291 131.6236 cm
Q
q
1 0 0 1 62.69291 98.42362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (struct rproc *rproc_get_by_phandle\(phandle phandle\)) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
24 0 obj
<<
/Length 3790
>>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 729.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.189398 Tw (Find an rproc handle using a device tree phandle. Returns the rproc handle on success, and NULL on) Tj T* 0 Tw .343828 Tw (failure. This function increments the remote processor's refcount, so always use rproc_put\(\) to decrement) Tj T* 0 Tw (it back once rproc isn't needed anymore.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 696.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Typical usage) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 410.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 276 re B*
Q
q
BT 1 0 0 1 0 254 Tm 12 TL /F3 10 Tf 0 0 0 rg (#include ) Tj (<) Tj (linux/remoteproc.h) Tj (>) Tj  T*  T* (/* in case we were given a valid 'rproc' handle */) Tj T* (int dummy_rproc_example\(struct rproc *my_rproc\)) Tj T* ({) Tj T* (      int ret;) Tj T*  T* (      /* let's power on and boot our remote processor */) Tj T* (      ret = rproc_boot\(my_rproc\);) Tj T* (      if \(ret\) {) Tj T* (              /*) Tj T* (               * something went wrong. handle it and leave.) Tj T* (               */) Tj T* (      }) Tj T*  T* (      /*) Tj T* (       * our remote processor is now powered on... give it some work) Tj T* (       */) Tj T*  T* (      /* let's shut it down now */) Tj T* (      rproc_shutdown\(my_rproc\);) Tj T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 377.8236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (API for implementors) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 320.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 48 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F3 10 Tf 12 TL (struct rproc *rproc_alloc\(struct device *dev, const char *name,) Tj T* (                              const struct rproc_ops *ops,) Tj T* (                              const char *firmware, int len\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 276.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .369984 Tw (Allocate a new remote processor handle, but don't register it yet. Required parameters are the underlying) Tj T* 0 Tw 1.202651 Tw (device, the name of this remote processor, platform-specific ops handlers, the name of the firmware to) Tj T* 0 Tw (boot this rproc with, and the length of private data needed by the allocating rproc driver \(in bytes\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 258.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (This function should be used by rproc implementations during initialization of the remote processor.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 228.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 2.000697 Tw (After creating an rproc handle using this function, and when ready, implementations should then call) Tj T* 0 Tw (rproc_add\(\) to complete the registration of the remote processor.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 210.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (On success, the new rproc is returned, and on failure, NULL.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 198.6236 cm
Q
q
1 0 0 1 62.69291 115.6236 cm
.960784 .960784 .862745 rg
n 0 83 469.8898 -83 re f*
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 6 57 Tm  T* ET
q
1 0 0 1 16 52 cm
q
0 0 0 rg
BT 1 0 0 1 0 2.5 Tm /F4 12.5 Tf 15 TL (Note) Tj T* ET
Q
Q
q
1 0 0 1 16 16 cm
q
BT 1 0 0 1 0 14 Tm -0.050015 Tw 12 TL /F2 10 Tf 0 0 0 rg (never) Tj /F1 10 Tf ( directly deallocate @rproc, even if it was not registered yet. Instead, when you need to unroll) Tj T* 0 Tw (rproc_alloc\(\), use rproc_free\(\).) Tj T* ET
Q
Q
q
1 J
1 j
.662745 .662745 .662745 RG
.5 w
n 0 83 m 469.8898 83 l S
n 0 0 m 469.8898 0 l S
n 0 0 m 0 83 l S
n 469.8898 0 m 469.8898 83 l S
Q
Q
q
1 0 0 1 62.69291 109.6236 cm
Q
 
endstream
endobj
25 0 obj
<<
/Length 4968
>>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 739.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (void rproc_free\(struct rproc *rproc\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 719.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Free an rproc handle that was allocated by rproc_alloc.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 677.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .410751 Tw (This function essentially unrolls rproc_alloc\(\), by decrementing the rproc's refcount. It doesn't directly free) Tj T* 0 Tw 1.061098 Tw (rproc; that would happen only if there are no other references to rproc and its refcount now dropped to) Tj T* 0 Tw (zero.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 644.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (int rproc_add\(struct rproc *rproc\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 624.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Register @rproc with the remoteproc framework, after it has been allocated with rproc_alloc\(\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 594.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .695697 Tw (This is called by the platform-specific rproc implementation, whenever a new remote processor device is) Tj T* 0 Tw (probed.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 552.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 4.065697 Tw (Returns 0 on success and an appropriate error code otherwise. Note: this function initiates an) Tj T* 0 Tw 3.294597 Tw (asynchronous firmware loading context, which will look for virtio devices supported by the rproc's) Tj T* 0 Tw (firmware.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 522.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .105542 Tw (If found, those virtio devices will be created and added, so as a result of registering this remote processor,) Tj T* 0 Tw (additional virtio drivers might get probed.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 489.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (int rproc_del\(struct rproc *rproc\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 469.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Unroll rproc_add\(\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 439.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.605697 Tw (This function should be called when the platform specific rproc implementation decides to remove the) Tj T* 0 Tw (rproc device. it should _only_ be called if a previous invocation of rproc_add\(\) has completed successfully.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 409.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 2.045984 Tw (After rproc_del\(\) returns, @rproc is still valid, and its last refcount should be decremented by calling) Tj T* 0 Tw (rproc_free\(\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 391.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Returns 0 on success and -EINVAL if @rproc isn't valid.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 358.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F3 10 Tf 12 TL (void rproc_report_crash\(struct rproc *rproc, enum rproc_crash_type type\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 338.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Report a crash in a remoteproc) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 296.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .398735 Tw (This function must be called every time a crash is detected by the platform specific rproc implementation.) Tj T* 0 Tw .573318 Tw (This should not be called from a non-remoteproc driver. This function can be called from atomic/interrupt) Tj T* 0 Tw (context.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 263.2236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Implementation callbacks) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 245.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (These callbacks should be provided by platform-specific remoteproc drivers:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 92.02362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 144 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 122 Tm /F3 10 Tf 12 TL (/**) Tj T* ( * struct rproc_ops - platform-specific device handlers) Tj T* ( * @start:    power on the device and boot it) Tj T* ( * @stop:     power off the device) Tj T* ( * @kick:     kick a virtqueue \(virtqueue id given as a parameter\)) Tj T* ( */) Tj T* (struct rproc_ops {) Tj T* (      int \(*start\)\(struct rproc *rproc\);) Tj T* (      int \(*stop\)\(struct rproc *rproc\);) Tj T* (      void \(*kick\)\(struct rproc *rproc, int vqid\);) Tj T* (};) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
26 0 obj
<<
/Length 5047
>>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
BT 1 0 0 1 0 14 Tm .959982 Tw 12 TL /F1 10 Tf 0 0 0 rg (Every remoteproc implementation should at least provide the -) Tj (>) Tj (start and -) Tj (>) Tj (stop handlers. If rpmsg/virtio) Tj T* 0 Tw (functionality is also desired, then the -) Tj (>) Tj (kick handler should be provided as well.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 687.0236 cm
q
BT 1 0 0 1 0 38 Tm 2.447633 Tw 12 TL /F1 10 Tf 0 0 0 rg (The -) Tj (>) Tj (start\(\) handler takes an rproc handle and should then power on the device and boot it \(use) Tj T* 0 Tw .811984 Tw (rproc-) Tj (>) Tj (priv to access platform-specific private data\). The boot address, in case needed, can be found in) Tj T* 0 Tw .292651 Tw (rproc-) Tj (>) Tj (bootaddr \(remoteproc core puts there the ELF entry point\). On success, 0 should be returned, and) Tj T* 0 Tw (on failure, an appropriate error code.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 657.0236 cm
q
BT 1 0 0 1 0 14 Tm .552339 Tw 12 TL /F1 10 Tf 0 0 0 rg (The -) Tj (>) Tj (stop\(\) handler takes an rproc handle and powers the device down. On success, 0 is returned, and) Tj T* 0 Tw (on failure, an appropriate error code.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 603.0236 cm
q
BT 1 0 0 1 0 38 Tm .487633 Tw 12 TL /F1 10 Tf 0 0 0 rg (The -) Tj (>) Tj (kick\(\) handler takes an rproc handle, and an index of a virtqueue where new message was placed) Tj T* 0 Tw 2.239983 Tw (in. Implementations should interrupt the remote processor and let it know it has pending messages.) Tj T* 0 Tw 2.367633 Tw (Notifying remote processors the exact virtqueue index to look in is optional: it is easy \(and not too) Tj T* 0 Tw (expensive\) to go through the existing virtqueues and look for new buffers in the used rings.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 570.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Binary Firmware Structure) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 528.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .831984 Tw (At this point remoteproc only supports ELF32 firmware binaries. However, it is quite expected that other) Tj T* 0 Tw 2.701412 Tw (platforms/devices which we'd want to support with this framework will be based on different binary) Tj T* 0 Tw (formats.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 498.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .538876 Tw (When those use cases show up, we will have to decouple the binary format from the framework core, so) Tj T* 0 Tw (we can support several binary formats without duplicating common code.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 468.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.981318 Tw (When the firmware is parsed, its various segments are loaded to memory according to the specified) Tj T* 0 Tw (device address \(might be a physical address if the remote processor is accessing memory directly\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 438.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .867984 Tw (In addition to the standard ELF segments, most remote processors would also include a special section) Tj T* 0 Tw (which we call "the resource table".) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 396.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.764269 Tw (The resource table contains system resources that the remote processor requires before it should be) Tj T* 0 Tw 1.249269 Tw (powered on, such as allocation of physically contiguous memory, or iommu mapping of certain on-chip) Tj T* 0 Tw (peripherals. Remotecore will only power up the device after all the resource table's requirement are met.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 354.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.534651 Tw (In addition to system resources, the resource table may also contain resource entries that publish the) Tj T* 0 Tw 1.802126 Tw (existence of supported features or configurations by the remote processor, such as trace buffers and) Tj T* 0 Tw (supported virtio devices \(and their configurations\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 336.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (The resource table begins with this header:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 98.82362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 228 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 206 Tm /F3 10 Tf 12 TL (/**) Tj T* ( * struct resource_table - firmware resource table header) Tj T* ( * @ver: version number) Tj T* ( * @num: number of resource entries) Tj T* ( * @reserved: reserved \(must be zero\)) Tj T* ( * @offset: array of offsets pointing at the various resource entries) Tj T* ( *) Tj T* ( * The header of the resource table, as expressed by this structure,) Tj T* ( * contains a version number \(should we need to change this format in the) Tj T* ( * future\), the number of available resource entries, and their offsets) Tj T* ( * in the table.) Tj T* ( */) Tj T* (struct resource_table {) Tj T* (      u32 ver;) Tj T* (      u32 num;) Tj T* (      u32 reserved[2];) Tj T* (      u32 offset[0];) Tj T* (} __packed;) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
27 0 obj
<<
/Length 3680
>>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.724983 Tw (Immediately following this header are the resource entries themselves, each of which begins with the) Tj T* 0 Tw (following resource entry header:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 563.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 168 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 146 Tm /F3 10 Tf 12 TL (/**) Tj T* ( * struct fw_rsc_hdr - firmware resource entry header) Tj T* ( * @type: resource type) Tj T* ( * @data: resource data) Tj T* ( *) Tj T* ( * Every resource entry begins with a 'struct fw_rsc_hdr' header providing) Tj T* ( * its @type. The content of the entry itself will immediately follow) Tj T* ( * this header, and it should be parsed according to the resource type.) Tj T* ( */) Tj T* (struct fw_rsc_hdr {) Tj T* (      u32 type;) Tj T* (      u8 data[0];) Tj T* (} __packed;) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 507.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL 1.858443 Tw (Some resources entries are mere announcements, where the host is informed of specific remoteproc) Tj T* 0 Tw 4.036905 Tw (configuration. Other entries require the host to do something \(e.g. allocate a system resource\).) Tj T* 0 Tw 1.12784 Tw (Sometimes a negotiation is expected, where the firmware requests a resource, and once allocated, the) Tj T* 0 Tw (host should provide back its details \(e.g. address of an allocated memory region\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 489.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Here are the various resource types that are currently supported:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 180.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 498 300 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 278 Tm /F3 10 Tf 12 TL (/**) Tj T* ( * enum fw_resource_type - types of resource entries) Tj T* ( *) Tj T* ( * @RSC_CARVEOUT:   request for allocation of a physically contiguous) Tj T* ( *                memory region.) Tj T* ( * @RSC_DEVMEM:     request to iommu_map a memory-based peripheral.) Tj T* ( * @RSC_TRACE:            announces the availability of a trace buffer into which) Tj T* ( *                the remote processor will be writing logs.) Tj T* ( * @RSC_VDEV:       declare support for a virtio device, and serve as its) Tj T* ( *                virtio header.) Tj T* ( * @RSC_LAST:       just keep this one at the end) Tj T* ( *) Tj T* ( * Please note that these values are used as indices to the rproc_handle_rsc) Tj T* ( * lookup table, so please keep them sane. Moreover, @RSC_LAST is used to) Tj T* ( * check the validity of an index before the lookup table is accessed, so) Tj T* ( * please update it as needed.) Tj T* ( */) Tj T* (enum fw_resource_type {) Tj T* (      RSC_CARVEOUT    = 0,) Tj T* (      RSC_DEVMEM      = 1,) Tj T* (      RSC_TRACE       = 2,) Tj T* (      RSC_VDEV        = 3,) Tj T* (      RSC_LAST        = 4,) Tj T* (};) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 148.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 6.133059 Tw (For more details regarding a specific resource type, please see its dedicated structure in) Tj T* 0 Tw (include/linux/remoteproc.h.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 106.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .119985 Tw (We also expect that platform-specific resource entries will show up at some point. When that happens, we) Tj T* 0 Tw .931412 Tw (could easily add a new RSC_PLATFORM type, and hand those resources to the platform-specific rproc) Tj T* 0 Tw (driver to handle.) Tj T* ET
Q
Q
 
endstream
endobj
28 0 obj
<<
/Length 1442
>>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 744.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Virtio and remoteproc) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 702.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 2.84152 Tw (The firmware should provide remoteproc information about virtio devices that it supports, and their) Tj T* 0 Tw 1.171412 Tw (configurations: a RSC_VDEV resource entry should specify the virtio device id \(as in virtio_ids.h\), virtio) Tj T* 0 Tw (features, virtio config space, vrings information, etc.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 660.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .226235 Tw (When a new remote processor is registered, the remoteproc framework will look for its resource table and) Tj T* 0 Tw .169987 Tw (will register the virtio devices it supports. A firmware may support any number of virtio devices, and of any) Tj T* 0 Tw (type \(a single remote processor can also easily support several rpmsg virtio devices this way, if desired\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 618.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 2.359983 Tw (Of course, RSC_VDEV resource entries are only good enough for static allocation of virtio devices.) Tj T* 0 Tw 2.31061 Tw (Dynamic allocations will also be made possible using the rpmsg bus \(similar to how we already do) Tj T* 0 Tw (dynamic allocations of rpmsg channels; read more about it in rpmsg.txt\).) Tj T* ET
Q
Q
 
endstream
endobj
29 0 obj
<<
/Nums [ 0 30 0 R 1 31 0 R 2 32 0 R 3 33 0 R 4 34 0 R 
  5 35 0 R ]
>>
endobj
30 0 obj
<<
/S /D /St 1
>>
endobj
31 0 obj
<<
/S /D /St 2
>>
endobj
32 0 obj
<<
/S /D /St 3
>>
endobj
33 0 obj
<<
/S /D /St 4
>>
endobj
34 0 obj
<<
/S /D /St 5
>>
endobj
35 0 obj
<<
/S /D /St 6
>>
endobj
xref
0 36
0000000000 65535 f 
0000000073 00000 n 
0000000134 00000 n 
0000000241 00000 n 
0000000353 00000 n 
0000000458 00000 n 
0000000577 00000 n 
0000000782 00000 n 
0000000987 00000 n 
0000001192 00000 n 
0000001397 00000 n 
0000001603 00000 n 
0000001809 00000 n 
0000001915 00000 n 
0000002199 00000 n 
0000002273 00000 n 
0000002386 00000 n 
0000002508 00000 n 
0000002635 00000 n 
0000002769 00000 n 
0000002907 00000 n 
0000003046 00000 n 
0000003169 00000 n 
0000003261 00000 n 
0000008816 00000 n 
0000012658 00000 n 
0000017678 00000 n 
0000022777 00000 n 
0000026509 00000 n 
0000028003 00000 n 
0000028092 00000 n 
0000028126 00000 n 
0000028160 00000 n 
0000028194 00000 n 
0000028228 00000 n 
0000028262 00000 n 
trailer
<<
/ID 
[<9a22b4bc121e8158fd1892a5dfc6ddd5><9a22b4bc121e8158fd1892a5dfc6ddd5>]
% ReportLab generated PDF document -- digest (http://www.reportlab.com)

/Info 13 0 R
/Root 12 0 R
/Size 36
>>
startxref
28296
%%EOF
